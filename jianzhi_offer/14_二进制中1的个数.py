# encoding: utf-8
"""
 @project:Data_Structure&&Algorithm
 @author: Jiang Hui
 @language:Python 3.7.2 [GCC 7.3.0] :: Anaconda, Inc. on linux
 @time: 4/9/19 11:39 AM
 @desc: 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示
"""

"""
【科普】
 关于十进制数在32位计算机中的二进制表示：（在计算机系统中，数值一律用补码来表示和存储）【十六进制负数以原码存储在内存上】
 
    1. 正数 5的表示法： 00000000 00000000 00000000 00000101 ,十六进制为 0x00000005 （正数的原码，反码，补码相同）
    
    2. 负数-5的表示法： （在计算机中，负数以原码的补码形式表示）
        -5的原码： 10000000 00000000 00000000 00000101
        -5的反码： 11111111 11111111 11111111 11111010 （除符号位以外，其他全部按位取反）
        -5的补码： 11111111 11111111 11111111 11111011 （在反码的基础上，加1）
        所以，计算机中-5表示为：11111111 11111111 11111111 11111011，十六进制为 0xfffffffb
    
    3. -1的表示法：
                  原码为：10000000 00000000 00000000 00000001
                  反码为：11111111 11111111 11111111 11111110
                  补码为：11111111 11111111 11111111 11111111   十六进制为：0xffffffff
    
        所以根据对于右移运算的理解，如果是负数，右移多少位，最左边添加多少个1，所以-1右移，结果始终为-1!
    
 关于二进制位运算，左移和右移的运算规则：
    1. 正数
        左移n位，最左边的n个数丢掉，右边补上n个0；
        右移n位，最右边的n个数丢掉，左边补上n个0；
    
    2. 负数
        左移n位，最左边的n个数丢掉，右边补上n个0；（同上）
        右移n位，最右边的n个数丢掉，左边补上n个1；（补1而不是0）
        
 整数的左移和右移运算比乘除2的效率高的多哦，所以在实际编程中尽可能多地用移位运算符代替乘除法.
 
 关于Python长整数类型的数，理论上可以为无限位，一般编程语言，int类型为32位，所以一方面为了避免移位运算中发生死循环，
 另一方面，保证我们的数与其他语言一致，我们把n进行转换，n = n&0xffffffff，即限制整数n的二进制表示为32位，不管n是正数还是负数，在
 计算机中，32的表示是一样的，只是实际代表的值不一样，但是对于我们用Python进行位运算时，一定要注意转换，限制整数的边界在32位!
"""


class Solution:
    # 算法思路：
    #   (1) 一个数和1进行'与'运算，如果返回0，说明该数最右边一位是0，如果返回1，说明该数最右边一位是1
    #   (2) 我们每进行一次比较，就把该数向右移一位，直至整个整数都变为0为止

    # 这个思路的确简单，但是存在一个致命的漏洞，那就是如果该数为负数的话，最终始终为1，会陷入死循环中
    # 于是我们得换个思路
    #   一开始也是把该数和1进行与运算，然后不再选择把数右移一位，而是把1左移一位就好了啊，1一直左移，最终数会溢出，得到0，循环结束
    # 编辑代码如下：

    # def NumberOf1(self, n):
    #     flag = 1
    #     count = 0
    #     while flag:
    #         if n & flag:  # n & flag并不是返回0或1哦，而是返回0或flag的值!!!
    #             count += 1
    #         flag = flag << 1
    #     return count

    # 遗憾的是，这个思路在Python中不可行，同样是陷入无限循环，原理是Python中整数不会发生溢出，在Python2中，超出int会自动转换成long类型
    # 而在Python3中，默认整数是一个可以无限放大的数值，直至整个计算机的内存溢出.

    # 新的算法思路：（给面试官带来惊喜的解法）
    # 把整数n减去1再和自身进行与运算,最终的结果是，会把整数n中最右边的1变为0，
    # 比如说 10010100 , 10010011 & 10010100 = 10010000 ,发现10010100中最右边的1的变为了0
    # 所以最终该数，最终会变成一个0
    # 用其他编程语言，上面的思想也可以实现，但是有个问题，在Python中，最后不会变为0，同样是变成很大的负数，不断开辟新空间
    def NumberOf1(self, n):
        count = 0
        if n < 0:
            # 进行与操作，这里只保留n的后32位，重点解释一下
            # 32位之前的二进制位，则全部变为了0，所以n实际上为0x0...0ffffffff
            # 因为在其他的编程语言中，int类型为4bytes即32bits，所以这里配合其他语言，将负数转成了32位的形式
            # 也就是转换完之后，我们把原来负数的后32位单独抽了出来，然后前面的二进制为全部变成了0，真实值是变了，
            # 但是我们题目要求的那32位的数没变就行了
            n = n & 0xffffffff
        while n:
            count += 1
            n = (n - 1) & n
        return count


if __name__ == '__main__':
    sol = Solution()
    print(sol.NumberOf1(1))
